# -*- coding: utf-8 -*-
"""bruteforce2x2 and 3x3_BFS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TGH0t-B9Zdb64YRtqnwZnB5HRtTawPXC
"""

from collections import deque

# Define the goal state
goal_state = ((0, 1), (2, 3))

# Define the possible moves
moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]

# Function to check if a state is valid
def is_valid(state):
    return all(0 <= state[i][j] < 4 for i in range(2) for j in range(2))

# Function to swap two elements in the puzzle state
def swap(state, i1, j1, i2, j2):
    state = list(list(row) for row in state)
    state[i1][j1], state[i2][j2] = state[i2][j2], state[i1][j1]
    return tuple(tuple(row) for row in state)

# BFS algorithm
def solve_2x2_puzzle(initial_state):
    queue = deque([(initial_state, [])])
    visited = set()

    while queue:
        current_state, current_moves = queue.popleft()

        if current_state == goal_state:
            return current_moves

        visited.add(current_state)

        zero_i, zero_j = None, None
        for i in range(2):
            for j in range(2):
                if current_state[i][j] == 0:
                    zero_i, zero_j = i, j

        for move in moves:
            new_i, new_j = zero_i + move[0], zero_j + move[1]
            if 0 <= new_i < 2 and 0 <= new_j < 2:
                new_state = swap(current_state, zero_i, zero_j, new_i, new_j)
                if is_valid(new_state) and new_state not in visited:
                    new_moves = current_moves + [move]
                    queue.append((new_state, new_moves))

    return None

# Example usage
initial_state = ((3,2), (1,0))
solution_moves = solve_2x2_puzzle(initial_state)

if solution_moves:
    print("Solution steps:", solution_moves)
else:
    print("No solution found.")

# now we are going to implement this for 3x3 as well

from queue import Queue

# Define the goal state
goal_state = ((1, 2, 3), (4, 5, 6), (7, 8, 0))

# Define the possible moves
moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]

# Function to check if a state is valid
def is_valid(x, y):
    return 0 <= x < 3 and 0 <= y < 3

# Function to swap two elements in the puzzle state
def swap(state, x1, y1, x2, y2):
    state = list(list(row) for row in state)
    state[x1][y1], state[x2][y2] = state[x2][y2], state[x1][y1]
    return tuple(tuple(row) for row in state)

# BFS algorithm
def solve_8_puzzle(initial_state):
    queue = Queue()
    queue.put((initial_state, []))
    visited = set()

    while not queue.empty():
        current_state, current_moves = queue.get()

        if current_state == goal_state:
            return current_moves

        visited.add(current_state)

        empty_x, empty_y = None, None
        for x in range(3):
            for y in range(3):
                if current_state[x][y] == 0:
                    empty_x, empty_y = x, y

        for move in moves:
            new_x, new_y = empty_x + move[0], empty_y + move[1]
            if is_valid(new_x, new_y):
                new_state = swap(current_state, empty_x, empty_y, new_x, new_y)
                if new_state not in visited:
                    new_moves = current_moves + [move]
                    queue.put((new_state, new_moves))

    return None

# Example usage
initial_state = ((8,7,6), (5, 4, 3), (2, 1, 0))
solution_moves = solve_8_puzzle(initial_state)

if solution_moves:
    print("Solution steps:", solution_moves)
else:
    print("No solution found.")